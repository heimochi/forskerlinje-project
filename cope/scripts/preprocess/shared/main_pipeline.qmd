---
title: "Preprocessing Pipeline"
format: html
execute:
echo: true
---

Description: This script sources shared helpers, loads and cleans each questionnaire 
(via `run_pipeline()`), and merges selected instruments into a single 
wide dataset (`merge_instruments()`) using respondent ID and context label.

```{r setup}
source("preprocess/shared/path.r")                  # data_dir
source("preprocess/shared/utilities.r")             # small helpers
source("preprocess/shared/00_consent.R")            # load_consent()
source("preprocess/shared/01_filter.r")             # filter_clinical_data()
source("preprocess/shared/02_data_types.r")         # data_types(), check_types()
source("preprocess/shared/03_merge.r", echo = TRUE, verbose = TRUE)              # merge_instruments()
source("preprocess/shared/04_handle_missing.r")                                  #
consent <- load_consent()
qes <- c("ATQ", "BAI", "BDI", "IIP", "MCQ", "PSWQ", "SCL", "REGT", "REGP") #regp not a part yet  , "REGT", "REGP"
```

```{r}
run_pipeline <- function(q_name, load_path) {
  source(load_path)
  data <- get(q_name)
  data <- filter_clinical_data(data, consent_df = consent, verbose = FALSE)
  data <- data_types(data)

  print(summary(data))                    # check
  invisible(data)                         # return silently
}
```

```{r}
#------------For testing purposes-------------------
ATQ <- run_pipeline("ATQ", "preprocess/atq.r")
BAI <- run_pipeline("BAI", "preprocess/bai.r")
```

```{r}
# Loop through all
all_data <- setNames(
  lapply(qes, function(q) run_pipeline(q, paste0("preprocess/", tolower(q), ".r"))),
  qes
)
```

```{r}
merged_all <- merge_instruments(all_data,
  keys = c("respondent_id", "assessment_context_label", "treatment_id"),
  verbose = TRUE
)

#QC merge
# no forbidden columns resurrected
intersect(names(merged_all), c("treatment_name", "treatment_type_id"))

# allowed contexts only
setdiff(unique(merged_all$assessment_context_label),
        c("Assessment","Admission","Post-treatment"))

# no duplicate keys in the final result
merged_all %>%
  count(respondent_id, assessment_context_label, treatment_id) %>%
  filter(n > 1)
```

```{r}
# 1) handle missing first
cleaned_all <- handle_missing_simple(merged_all, max_missing_to_impute = 1)

# 2) then coverage on the cleaned data
coverage_by_instrument(cleaned_all)
flag_low_coverage(cleaned_all, thresh = 85)

```

```{r}

coverage_by_instrument(merged_all)
flag_low_coverage(merged_all, thresh = 85)

```